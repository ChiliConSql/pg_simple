{"name":"Pg simple","tagline":"A simple wrapper over psycopg2 with support for common SQL functions","body":"# pg_simple\r\n\r\nThe `pg_simple` module provides a simple yet efficient layer over `psycopg2` providing Python API for common SQL functions, explicit and implicit transactions management and database connection pooling for single and multi-threaded applications.\r\n\r\n`pg_simple` is not intended to provide ORM-like functionality, rather to make it easier to interact with the PostgreSQL database from python code for direct SQL access using convenient wrapper methods. The module wraps the excellent `psycopg2` library and most of the functionality is provided by this behind the scenes.\r\n\r\nThe `pg_simple` module provides:\r\n\r\n* Simplified handling of database connections/cursor\r\n* Connection pool for single or multithreaded access\r\n* Python API to wrap basic SQL functionality: select, update, delete, join et al\r\n* Query results as python namedtuple and dict objects (using `psycopg2.extras.NamedTupleCursor` and `psycopg2.extras.DictCursor` respectively)\r\n* Debug logging support\r\n\r\n\r\n## Installation\r\n\r\nWith `pip` or `easy_install`:\r\n\r\n```pip install pg_simple```\r\n\r\nor:\r\n\r\n```easy_install pg_simple```\r\n\r\nor from the source:\r\n\r\n```python setup.py install```\r\n\r\n\r\n##30 Seconds Quick-start Guide\r\n\r\n* Step 1: Initialize a connection pool manager using `pg_simple.config_pool()`\r\n* Step 2: Create a database connection and cursor by instantiating a `pg_simple.PgSimple` object\r\n\r\nHere's a pseudo-example to illustrate the basic concepts:\r\n\r\n```python\r\nimport pg_simple\r\n\r\npg_simple.config_pool(dsn='dbname=my_db user=my_username ...')\r\n\r\nwith pg_simple.PgSimple() as db:\r\n    db.insert('table_name',\r\n              data={'column': 123,\r\n                    'another_column': 'blah blah'})\r\n    db.commit()\r\n\r\nwith pg_simple.PgSimple() as db1:\r\n    rows = db1.fetchall('table_name')\r\n```\r\n\r\n\r\n##Connection pool management\r\n\r\n###Initialize the connection pool\r\n\r\n```python\r\nimport pg_simple\r\n\r\npg_simple.config_pool(max_conn=250,\r\n                      expiration=60, # idle timeout = 60 seconds\r\n                      host='localhost',\r\n                      port=5432,\r\n                      database='pg_simple',\r\n                      user='postgres',\r\n                      password='secret')\r\n```\r\n\r\nor, using `dsn`:\r\n\r\n```python\r\npg_simple.config_pool(max_conn=250,\r\n                      expiration=60,\r\n                      dsn='dbname=database_name user=postgres password=secret')\r\n\r\n```\r\n\r\nor, using `db_url`:\r\n\r\n```python\r\npg_simple.config_pool(max_conn=250,\r\n                      expiration=60,\r\n                      db_url= 'postgres://username:password@hostname:numeric_port/database')\r\n\r\n```\r\n\r\nThe above snippets will create a connection pool capable of accommodating a maximum of 250 concurrent database connections. Once that limit is reached and the pool does not contain any idle connections, all subsequent new connection request will result in a `PoolError` exception (until the pool gets refilled with idle connections).\r\n\r\nTake caution to properly clean up all `pg_simple.PgSimple` objects after use (wrap the object inside python try-finally block or `with` statement). Once the object is released, it will quietly return the internal database connction to the idle pool. Failure to dispose `PgSimple` properly may result in pool exhaustion error.\r\n\r\n\r\n###Configure connection pool for thread-safe access\r\n\r\nThe default `SimpleConnectionPool` pool manager is not thread-safe. To utilize the connection pool in multi-threaded apps, use the `ThreadedConnectionPool`:\r\n\r\n```python\r\npg_simple.config_pool(max_conn=250,\r\n                      expiration=60,\r\n                      pool_manager=ThreadedConnectionPool,\r\n                      dsn='...')\r\n```\r\n\r\n\r\n###Disable connection pooling\r\n\r\nTo disable connection pooling completely, set the `disable_pooling` parameter to True:\r\n\r\n```python\r\npg_simple.config_pool(disable_pooling=True, dsn='...')\r\n```\r\n\r\nAll database requests on this pool will create new connections on the fly, and all connections returned to the pool (upon disposal of `PgSimple` object or by explicitly invoking `pool.put_conn()`) will be discarded immediately.\r\n\r\n\r\n###Obtaining the current connection pool manager\r\n\r\nCall the `pg_simple.get_pool()` method to get the current pool:\r\n\r\n```python\r\npool = pg_simple.get_pool()\r\n```\r\n\r\n\r\n###Garbage collect stale connections\r\n\r\nTo explicitly purge the pool of stale database connections (whose duration of stay in the pool exceeds the `expiration` timeout), invoke the `pool.purge_expired_connections()` method:\r\n\r\n```python\r\npool = pg_simple.get_pool()\r\npool.purge_expired_connections()\r\n```\r\n\r\nNote that the pool is automatically scavenged for stale connections when an idle connection is returned to the pool (using the `pool.put_conn()` method).\r\n\r\n\r\n## Basic Usage\r\n\r\n### Connecting to the posgtresql server\r\n\r\nThe following snippet will connect to the posgtresql server and allocate a cursor:\r\n\r\n```python\r\nimport sys\r\nimport pg_simple\r\n\r\ndb = pg_simple.PgSimple(log=sys.stdout,\r\n                        log_fmt=lambda x: '>> %s' % (x if isinstance(x, str) else x.query),\r\n                        nt_cursor=True)\r\n```\r\n\r\nBy default `PgSimple` generates result sets as `collections.namedtuple` objects (using `psycopg2.extras.NamedTupleCursor`). If you want to access the retrieved records using an interface similar to the Python dictionaries (using `psycopg2.extras.DictCursor`), set the `nt_cursor` parameter to `False`:\r\n\r\n```python\r\ndb = pg_simple.PgSimple(nt_cursor=False)\r\n```\r\n\r\n### Raw SQL execution\r\n\r\n```python\r\n>>> db.execute('SELECT tablename FROM pg_tables WHERE schemaname=%s and tablename=%s', ['public', 'books'])\r\n<cursor object at 0x102352a50; closed: 0>\r\n```\r\n\r\n### Dropping and creating tables\r\n\r\n```python\r\ndb.drop('books')\r\n\r\ndb.create('books',\r\n          '''\r\n\"id\" SERIAL NOT NULL,\r\n\"type\" VARCHAR(20) NOT NULL,\r\n\"name\" VARCHAR(40) NOT NULL,\r\n\"price\" MONEY NOT NULL,\r\n\"published\" DATE NOT NULL,\r\n\"modified\" TIMESTAMP(6) NOT NULL DEFAULT now()\r\n'''\r\n)\r\n\r\ndb.execute('''ALTER TABLE \"books\" ADD CONSTRAINT \"books_pkey\" PRIMARY KEY (\"id\")''')\r\ndb.commit()\r\n\r\n```\r\n\r\n### Emptying a table or set of tables\r\n\r\n```python\r\ndb.truncate('tbl1')\r\ndb.truncate('tbl2, tbl3', restart_identity=True, cascade=True)\r\ndb.commit()\r\n```\r\n\r\n### Inserting rows\r\n\r\n```python\r\nfor i in range(1, 10):\r\n    db.insert(\"books\",\r\n              {\"genre\": \"fiction\",\r\n               \"name\": \"Book Name vol. %d\" % i,\r\n               \"price\": 1.23 * i,\r\n               \"published\": \"%d-%d-1\" % (2000 + i, i)})\r\n\r\ndb.commit()\r\n```\r\n\r\n### Updating rows\r\n\r\n```python\r\nwith pg_simple.PgSimple() as db1:\r\n    db1.update('books',\r\n               data={'name': 'An expensive book',\r\n                     'price': 998.997,\r\n                     'genre': 'non-fiction',\r\n                     'modified': 'NOW()'},\r\n               where=('published = %s', [datetime.date(2001, 1, 1)]))\r\n               \r\n    db1.commit()\r\n```\r\n\r\n### Deleting rows\r\n\r\n```python\r\ndb.delete('books', where=('published >= %s', [datetime.date(2005, 1, 31)]))\r\ndb.commit()\r\n```\r\n\r\n### Inserting/updating/deleting rows with return value\r\n\r\n```python\r\nrow = db.insert(\"books\",\r\n                {\"type\": \"fiction\",\r\n                 \"name\": \"Book with ID\",\r\n                 \"price\": 123.45,\r\n                 \"published\": \"1997-01-31\"},\r\n                returning='id')\r\nprint(row.id)\r\n\r\nrows = db.update('books',\r\n                 data={'name': 'Another expensive book',\r\n                       'price': 500.50,\r\n                       'modified': 'NOW()'},\r\n                 where=('published = %s', [datetime.date(2006, 6, 1)]),\r\n                 returning='modified')\r\nprint(rows[0].modified)\r\n\r\nrows = db.delete('books', \r\n                 where=('published >= %s', [datetime.date(2005, 1, 31)]), \r\n                 returning='name')\r\nfor r in rows:\r\n    print(r.name)\r\n```\r\n\r\n### Fetching a single record\r\n\r\n```python\r\nbook = db.fetchone('books', \r\n                   fields=['name', 'published'], \r\n                   where=('published = %s', [datetime.date(2002, 2, 1)]))\r\n                   \r\nprint(book.name + 'was published on ' + book[1])\r\n```\r\n\r\n### Fetching multiple records\r\n\r\n```python\r\nbooks = db.fetchall('books',\r\n                    fields=['name AS n', 'genre AS g'],\r\n                    where=('published BETWEEN %s AND %s', [datetime.date(2005, 2, 1), datetime.date(2009, 2, 1)]),\r\n                    order=['published', 'DESC'], \r\n                    limit=5, \r\n                    offset=2)\r\n\r\nfor book in books:\r\n    print(book.n + 'belongs to ' + book[1])\r\n```\r\n\r\n### Explicit database transaction management\r\n\r\n```python\r\nwith pg_simple.PgSimple() as _db:\r\n    try:\r\n        _db.execute('Some SQL statement')\r\n        _db.commit()\r\n    except:\r\n        _db.rollback()\r\n```\r\n\r\n### Implicit database transaction management\r\n\r\n```python\r\nwith pg_simple.PgSimple() as _db:\r\n    _db.execute('Some SQL statement')\r\n    _db.commit()\r\n```\r\n\r\nThe above transaction will automatically be rolled back should something go awry.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}